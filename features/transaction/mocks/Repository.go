// // Code generated by mockery v2.37.1. DO NOT EDIT.

package mocks

// import (
// 	transaction "tukangku/features/transaction"

// 	mock "github.com/stretchr/testify/mock"
// )

// // Repository is an autogenerated mock type for the Repository type
// type Repository struct {
// 	mock.Mock
// }

// // AddTransaction provides a mock function with given fields: userID, JobID, JobPrice
// func (_m *Repository) AddTransaction(userID uint, JobID uint, JobPrice uint) (transaction.Transaction, error) {
// 	ret := _m.Called(userID, JobID, JobPrice)

// 	var r0 transaction.Transaction
// 	var r1 error
// 	if rf, ok := ret.Get(0).(func(uint, uint, uint) (transaction.Transaction, error)); ok {
// 		return rf(userID, JobID, JobPrice)
// 	}
// 	if rf, ok := ret.Get(0).(func(uint, uint, uint) transaction.Transaction); ok {
// 		r0 = rf(userID, JobID, JobPrice)
// 	} else {
// 		r0 = ret.Get(0).(transaction.Transaction)
// 	}

// 	if rf, ok := ret.Get(1).(func(uint, uint, uint) error); ok {
// 		r1 = rf(userID, JobID, JobPrice)
// 	} else {
// 		r1 = ret.Error(1)
// 	}

// 	return r0, r1
// }

// // CallBack provides a mock function with given fields: noInvoice
// func (_m *Repository) CallBack(noInvoice string) (*transaction.TransactionList, error) {
// 	ret := _m.Called(noInvoice)

// 	var r0 *transaction.TransactionList
// 	var r1 error
// 	if rf, ok := ret.Get(0).(func(string) (*transaction.TransactionList, error)); ok {
// 		return rf(noInvoice)
// 	}
// 	if rf, ok := ret.Get(0).(func(string) *transaction.TransactionList); ok {
// 		r0 = rf(noInvoice)
// 	} else {
// 		if ret.Get(0) != nil {
// 			r0 = ret.Get(0).(*transaction.TransactionList)
// 		}
// 	}

// 	if rf, ok := ret.Get(1).(func(string) error); ok {
// 		r1 = rf(noInvoice)
// 	} else {
// 		r1 = ret.Error(1)
// 	}

// 	return r0, r1
// }

// // CheckTransaction provides a mock function with given fields: transactionID
// func (_m *Repository) CheckTransaction(transactionID uint) (*transaction.Transaction, error) {
// 	ret := _m.Called(transactionID)

// 	var r0 *transaction.Transaction
// 	var r1 error
// 	if rf, ok := ret.Get(0).(func(uint) (*transaction.Transaction, error)); ok {
// 		return rf(transactionID)
// 	}
// 	if rf, ok := ret.Get(0).(func(uint) *transaction.Transaction); ok {
// 		r0 = rf(transactionID)
// 	} else {
// 		if ret.Get(0) != nil {
// 			r0 = ret.Get(0).(*transaction.Transaction)
// 		}
// 	}

// 	if rf, ok := ret.Get(1).(func(uint) error); ok {
// 		r1 = rf(transactionID)
// 	} else {
// 		r1 = ret.Error(1)
// 	}

// 	return r0, r1
// }

// // NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// // The first argument is typically a *testing.T value.
// func NewRepository(t interface {
// 	mock.TestingT
// 	Cleanup(func())
// }) *Repository {
// 	mock := &Repository{}
// 	mock.Mock.Test(t)

// 	t.Cleanup(func() { mock.AssertExpectations(t) })

// 	return mock
// }
